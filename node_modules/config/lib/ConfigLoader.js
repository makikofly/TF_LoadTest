"use strict";
var DEFAULT_CLONE_DEPTH = 6;

// For compatibility between 0.6.x and 0.8.x
var path = require('path');
var fs = require('fs');
var semver = require('semver');
fs.exists = semver.lt(process.version, '0.8.0') ? path.exists : require('fs').exists;
fs.existsSync = semver.lt(process.version, '0.8.0') ? path.existsSync : require('fs').existsSync;

exports.ConfigLoader = ConfigLoader;

/**
 * Load the application configuration from a valid set of configuration files.
 * @param configDir {string} The configuration directory to look in.
 * @param appEnv {string} The application environment to load configuration 
 * for (e.g. 'development', 'staging', 'production').
 */
function ConfigLoader(configDir,appEnv) {

    if('string'!==typeof configDir) {
        throw new Error('configObj is not a valid string');
    }

    // TODO: Ideally we would die here if the specified path was not a directory but we're not able to
    // do that yet without breaking dependent code. Should fix at our soonest opportunity.
    if('string'!==typeof appEnv) {
        throw new Error('appEnv is not a valid string');
    }

    this.configDir = configDir;
    this.appEnv = appEnv;
}

/**
 * Load the default configuration file to config object and then overlay that
 * with the values in the target configuration. Afterwards, make the configuration
 * immutable, so it cannot be changed during runtime.
 * @returns {Object} The configuration object, ready for use.
 */
ConfigLoader.prototype.loadFileConfigs = function() {

    var fs = require('fs');
    var self = this;
    var result = {};

    // Read each file in turn
    var fileNames = ['default.js',this.appEnv+'.js'];

    var cnt = 0;
    fileNames.forEach(function(currFilename) {
        // Try merging the config object into this object
        var fullFilename = path.join(self.configDir,currFilename);
        if (!fs.existsSync(fullFilename)) {
            //console.debug('Error: Configuration file: '+currFilename+' is not present at: '+self.configDir);
        } else {
            //console.debug('FOUND: Configuration file: '+currFilename+' is not present at: '+self.configDir);
            var configObj = self.parseFile(fullFilename);
            if (configObj) {
                self.extendDeep(result,configObj);
            }
        }
        if (++cnt === fileNames.length)
            self.makeObjImmutable(result);
    });

    // Attach the config.prototype to all sub-objects.
    this.attachProtoDeep(result);

    var util = require('util');
    var appRegion = result.region;
    var AppConfig = require('./AppConfig').AppConfig;

    // Return the configuration object
    return new AppConfig(result,appRegion);
};

/**
 * Make the configuration immutable, so the structure cannot be modified
 * after it is loaded.
 */
ConfigLoader.prototype.makeObjImmutable = function(obj, depth) {

    if (typeof(depth) != 'number')
        depth = DEFAULT_CLONE_DEPTH;

    if (depth < 0 || typeof obj !== 'object')
        return;

    // Cycle through each element of the object to make immutable
    for (var prop in obj) {
        this.makeImmutable(obj, prop);       // make immutable!

        if (this.isObject(obj[prop])) {     // recurse into objects
            this.makeObjImmutable(obj[prop], depth - 1);
        }
    }
};

ConfigLoader.prototype.parseFile = function(fullFilename) {
    
    var fs = require('fs');
    
    // Initialize
    var t = this,
    extension = fullFilename.substr(fullFilename.lastIndexOf('.') + 1),
    configObject = null,
    fileContent = null;
    
    // Return null if the file doesn't exist.
    // Note that all methods here are the Sync versions.  This allows the
    // config package to follow the same calling semantics as require('filename')
    // which is also synchronous.
    try {
        var stat = fs.statSync(fullFilename);
        if (!stat || stat.size < 1) {
            return null;
        }
    } catch (e1) {
        return null;
    }
    
    // Try loading the file.
    try {
        fileContent = fs.readFileSync(fullFilename, 'UTF-8');
    }
    catch (e2) {
        throw new Error('Config file ' + fullFilename + ' cannot be read');
    }
    
    // Parse the file based on extension
    try {
        if (extension == 'json') {
            // Allow comments in JSON files
            configObject = JSON.parse(this.stripComments(fileContent));
        }
        else if (extension == 'js') {
            // Use the built-in parser for .js files
            delete require.cache[fullFilename];
            configObject = require(fullFilename);
        }
    }
    catch (e3) {
        throw new Error("Cannot parse config file: '" + fullFilename + "': " + e3);
    }
    
    return configObject;
};


/**
 * reload the configuration files on request.
 */
ConfigLoader.prototype.reload = function() {
    
    originalConfig = null;
    this._loadFileConfigs();
};


/**
 * Extend an object, and any object it contains.
 *
 * This does not replace deep objects, but dives into them
 * replacing individual elements instead.
 *
 * @protected
 * @method _extendDeep
 * @param mergeInto {object} The object to merge into
 * @param mergeFrom... {object...} - Any number of objects to merge from
 * @param depth {integer} An optional depth to prevent recursion.  Default: 20.
 * @return {object} The altered mergeInto object is returned
 */
ConfigLoader.prototype.extendDeep = function(mergeInto) {

    // Initialize
    var self = this;
    var vargs = Array.prototype.slice.call(arguments, 1);
    var depth = vargs.pop();
    if (typeof(depth) != 'number') {
        vargs.push(depth);
        depth = DEFAULT_CLONE_DEPTH;
    }
    
    // Recursion detection
    if (depth < 0)
        return mergeInto;
    
    // Cycle through each object to extend
    vargs.forEach(function(mergeFrom) {
            
            // Cycle through each element of the object to merge from
            for (var prop in mergeFrom) {
                
                // Extend recursively if both elements are objects
                if (self.isObject(mergeInto[prop]) && self.isObject(mergeFrom[prop])) {
                    self.extendDeep(mergeInto[prop], mergeFrom[prop], depth - 1);
                } else if (mergeFrom[prop] && typeof mergeFrom[prop] == 'object') {
                    // Copy recursively if the mergeFrom element is an object (or array or fn)
                    mergeInto[prop] = self.cloneDeep(mergeFrom[prop], depth - 1);
                } else {
                    // Simple assignment otherwise
                    mergeInto[prop] = mergeFrom[prop];
                }
            }
        });
    
    // Chain
    return mergeInto;
};

/**
 * Return a deep copy of the specified object.
 *
 * This returns a new object with all elements copied from the specified
 * object.  Deep copies are made of objects and arrays so you can do anything
 * with the returned object without affecting the input object.
 *
 * @protected
 * @method _cloneDeep
 * @param copyFrom {object} The original object to copy from
 * @param depth {integer} An optional depth to prevent recursion.  Default: 20.
 * @return {object} A new object with the elements copied from the copyFrom object
 */
ConfigLoader.prototype.cloneDeep = function(obj, depth) {
    
    // Recursion detection
    depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);
    if (depth < 0) {
        return {};
    }
    
    // Create the copy of the correct type
    var copy = Array.isArray(obj) ? [] : {};
    
    // Cycle through each element
    for (var prop in obj) {
        
        // Call recursively if an object or array
        if (typeof obj[prop] == 'object') {
            copy[prop] = this.cloneDeep(obj[prop], depth - 1);
        }
        else {
            copy[prop] = obj[prop];
        }
    }
    
    // Return the copied object
    return copy;
};

/**
 * <p>Make a configuration property immutable (assuring it cannot be changed
 * from the current value).</p>
 *
 * <p>
 * This operation cannot be un-done.
 * </p>
 * <p><i>
 *
 * This method was built for disabling runtime changes to configuration values,
 * but it can be applied to <u>any</u> javascript object.
 * </i></p>
 *
 * <p>Example:</p>
 * <pre>
 *   var CONFIG = require('config').customer;
 *   ...
 *
 *   // Obtain a DB connection using CONFIG parameters
 *   database.open(CONFIG.db.name, CONFIG.db.port);
 *   ...
 *
 *   // Don't allow database changes after connect
 *   CONFIG.makeImmutable(CONFIG.db, 'name');
 *   CONFIG.makeImmutable(CONFIG.db, 'port');
 * </pre>
 *
 * @method makeImmutable
 * @param object {object} - The object to attach an immutable property into.
 * @param property {string} - The name of the property to make immutable.
 * @param value {mixed} - (optional) Set the property value to this (otherwise leave alone)
 * @return object {object} - The original object is returned - for chaining.
 */
ConfigLoader.prototype.makeImmutable = function(object, property, value) {

    // Use the existing value if a new value isn't specified
    value = (typeof value == 'undefined') ? object[property] : value;
    
    // Disable writing, and make sure the property cannot be re-configured.
    Object.defineProperty(object, property, {
            value : value,
                writable : false,
                configurable: false
                });
    
    return object;
};

/**
 * Is the specified argument a regular javascript object?
 *
 * The argument is an object if it's a JS object, but not an array.
 *
 * @protected
 * @method _isObject
 * @param arg {MIXED} An argument of any type.
 * @return {boolean} TRUE if the arg is an object, FALSE if not
 */
ConfigLoader.prototype.isObject = function(obj) {
    return (typeof obj == 'object') && !(Array.isArray(obj));
};

/**
 * Attach the Config class prototype to all config objects recursively.
 *
 * <p>
 * This allows you to do anything with CONFIG sub-objects as you can do with
 * the top-level CONFIG object.  It's so you can do this:
 * </p>
 *
 * <pre>
 *   var CUST_CONFIG = require('config').Customer;
 *   CUST_CONFIG.watch(...)
 * </pre>
 *
 * @protected
 * @method _attachProtoDeep
 * @param toObject
 * @param depth
 * @return toObject
 */
ConfigLoader.prototype.attachProtoDeep = function(toObject, depth) {

  // Recursion detection
  depth = (depth === null ? DEFAULT_CLONE_DEPTH : depth);
  if (depth < 0) {
    return toObject;
  }

  // Adding ConfigLoader.prototype methods directly to toObject as hidden properties
  // because adding to toObject.__proto__ exposes the function in toObject
  for (var fnName in ConfigLoader.prototype) {
    this.makeHidden(toObject, fnName, ConfigLoader.prototype[fnName]);
  }

  // Cycle through each element
  for (var prop in toObject) {

    // Call recursively if an object
    if (this.isObject(toObject[prop])) {
      this.attachProtoDeep(toObject[prop], depth - 1);
    }
  }

  // Return the original object
  return toObject;

};


/**
 * <p>Make a configuration property hidden so it doesn't appear when enumerating
 * elements of the object.</p>
 *
 * <p>
 * The property still exists and can be read from and written to, but it won't
 * show up in for ... in loops, Object.keys(), or JSON.stringify() type methods.
 * </p>
 *
 * <p>
 * If the property already exists, it will be made hidden.  Otherwise it will
 * be created as a hidden property with the specified value.
 * </p>
 *
 * <p><i>
 * This method was built for hiding configuration values, but it can be applied
 * to <u>any</u> javascript object.
 * </i></p>
 *
 * <p>Example:</p>
 * <pre>
 *   var CONFIG = require('config');
 *   ...
 *
 *   // Hide the Amazon S3 credentials
 *   CONFIG.makeHidden(CONFIG.amazonS3, 'access_id');
 *   CONFIG.makeHidden(CONFIG.amazonS3, 'secret_key');
 * </pre>
 *
 * @method makeHidden
 * @param object {object} - The object to make a hidden property into.
 * @param property {string} - The name of the property to make hidden.
 * @param value {mixed} - (optional) Set the property value to this (otherwise leave alone)
 * @return object {object} - The original object is returned - for chaining.
 */
ConfigLoader.prototype.makeHidden = function(object, property, value) {

  // Use the existing value if the new value isn't specified
  value = (typeof value == 'undefined') ? object[property] : value;

  // Create the hidden property
  Object.defineProperty(object, property, {
    value: value,
    enumerable : false
  });

  return object;
}


/**
 * Strip all Javascript type comments from the string.
 *
 * The string is usually a file loaded from the O/S, containing
 * newlines and javascript type comments.
 *
 * Thanks to James Padolsey, and all who conributed to this implementation.
 * http://james.padolsey.com/javascript/javascript-comment-removal-revisted/
 *
 * @protected
 * @method stripComments
 * @param fileString {string} The string to strip comments from
 * @return {string} The string with comments stripped.
 */
ConfigLoader.prototype.stripComments = function(fileStr) {

  var uid = '_' + +new Date(),
      primitives = [],
      primIndex = 0;

  return (
    fileStr

    /* Remove strings */
    .replace(/(['"])(\\\1|.)+?\1/g, function(match){
      primitives[primIndex] = match;
      return (uid + '') + primIndex++;
    })

    /* Remove Regexes */
    .replace(/([^\/])(\/(?!\*|\/)(\\\/|.)+?\/[gim]{0,3})/g, function(match, $1, $2){
      primitives[primIndex] = $2;
      return $1 + (uid + '') + primIndex++;
    })

    /*
    - Remove single-line comments that contain would-be multi-line delimiters
        E.g. // Comment /* <--
    - Remove multi-line comments that contain would be single-line delimiters
        E.g. /* // <--
   */
    .replace(/\/\/.*?\/?\*.+?(?=\n|\r|$)|\/\*[\s\S]*?\/\/[\s\S]*?\*\//g, '')

    /*
    Remove single and multi-line comments,
    no consideration of inner-contents
   */
    .replace(/\/\/.+?(?=\n|\r|$)|\/\*[\s\S]+?\*\//g, '')

    /*
    Remove multi-line comments that have a replaced ending (string/regex)
    Greedy, so no inner strings/regexes will stop it.
   */
    .replace(RegExp('\\/\\*[\\s\\S]+' + uid + '\\d+', 'g'), '')

    /* Bring back strings & regexes */
    .replace(RegExp(uid + '(\\d+)', 'g'), function(match, n){
      return primitives[n];
    })
  );

};

